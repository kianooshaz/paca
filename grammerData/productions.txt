[
    "states[0].kernel\nLookahead    Production\n$    P' -> . P",
    "states[1].kernel\nLookahead    Production\n$    P' -> P .",
    "states[2].kernel\nLookahead    Production\n$    P -> program . id output ; declarations subprogram_declaration begin optional_statment end.",
    "states[3].kernel\nLookahead    Production\n$    P -> program id . output ; declarations subprogram_declaration begin optional_statment end.",
    "states[3].epsilon\nLookahead    Production\n;    output -> .",
    "states[4].kernel\nLookahead    Production\n$    P -> program id output . ; declarations subprogram_declaration begin optional_statment end.",
    "states[5].kernel\nLookahead    Production\n;    output -> ( . id_list )",
    "states[6].kernel\nLookahead    Production\n$    P -> program id output ; . declarations subprogram_declaration begin optional_statment end.",
    "states[6].epsilon\nLookahead    Production\nfunction procedure begin var    declarations -> .",
    "states[7].kernel\nLookahead    Production\n;    output -> ( id_list . )\n) ,    id_list -> id_list . , id",
    "states[8].kernel\nLookahead    Production\n) , :    id_list -> id .",
    "states[9].kernel\nLookahead    Production\n$    P -> program id output ; declarations . subprogram_declaration begin optional_statment end.\nfunction procedure begin var    declarations -> declarations . var id_list : type ;",
    "states[9].epsilon\nLookahead    Production\nbegin    subprogram_declaration -> .",
    "states[10].kernel\nLookahead    Production\n) , :    id_list -> id_list , . id",
    "states[11].kernel\nLookahead    Production\n;    output -> ( id_list ) .",
    "states[12].kernel\nLookahead    Production\nfunction procedure begin var    declarations -> declarations var . id_list : type ;",
    "states[13].kernel\nLookahead    Production\n$    P -> program id output ; declarations subprogram_declaration . begin optional_statment end.",
    "states[14].kernel\nLookahead    Production\nbegin ;    subprogram_declaration -> subprogram_declarations . subprogram_declaration ;",
    "states[14].epsilon\nLookahead    Production\n;    subprogram_declaration -> .",
    "states[15].kernel\nLookahead    Production\nfunction procedure ;    subprogram_declarations -> supprogram_head . declarations compound_statment",
    "states[15].epsilon\nLookahead    Production\nbegin var    declarations -> .",
    "states[16].kernel\nLookahead    Production\nvar begin    supprogram_head -> function . id arguments : standard_type ;",
    "states[17].kernel\nLookahead    Production\nvar begin    supprogram_head -> procedure . id arguments ;",
    "states[18].kernel\nLookahead    Production\n) , :    id_list -> id_list , id .",
    "states[19].kernel\nLookahead    Production\nfunction procedure begin var    declarations -> declarations var id_list . : type ;\n: ,    id_list -> id_list . , id",
    "states[20].kernel\nLookahead    Production\n$    P -> program id output ; declarations subprogram_declaration begin . optional_statment end.",
    "states[20].epsilon\nLookahead    Production\nend.    optional_statment -> .",
    "states[21].kernel\nLookahead    Production\nbegin ;    subprogram_declaration -> subprogram_declarations subprogram_declaration . ;",
    "states[22].kernel\nLookahead    Production\nfunction procedure ;    subprogram_declarations -> supprogram_head declarations . compound_statment\nbegin var    declarations -> declarations . var id_list : type ;",
    "states[23].kernel\nLookahead    Production\nvar begin    supprogram_head -> function id . arguments : standard_type ;",
    "states[23].epsilon\nLookahead    Production\n:    arguments -> .",
    "states[24].kernel\nLookahead    Production\nvar begin    supprogram_head -> procedure id . arguments ;",
    "states[24].epsilon\nLookahead    Production\n;    arguments -> .",
    "states[25].kernel\nLookahead    Production\nfunction procedure begin var    declarations -> declarations var id_list : . type ;",
    "states[26].kernel\nLookahead    Production\n$    P -> program id output ; declarations subprogram_declaration begin optional_statment . end.",
    "states[27].kernel\nLookahead    Production\nend. end ;    optional_statment -> statment_list .\nend. ; end    statment_list -> statment_list . ; optional_statment",
    "states[28].kernel\nLookahead    Production\nend. ; end    statment_list -> statment .",
    "states[29].kernel\nLookahead    Production\nend. ; end else    statment -> varible . := expr",
    "states[30].kernel\nLookahead    Production\nend. ; end else    statment -> procedure_statment .",
    "states[31].kernel\nLookahead    Production\nend. ; end else    statment -> compound_statment .",
    "states[32].kernel\nLookahead    Production\nend. ; end else    statment -> if . expr then statment\nend. ; end else    statment -> if . expr then statment else statment",
    "states[33].kernel\nLookahead    Production\nend. ; end else    statment -> while . expr do statment",
    "states[34].kernel\nLookahead    Production\nend. ; end else    statment -> for . varible := expr st_for st_for2 do statment",
    "states[35].kernel\nLookahead    Production\n:=    varible -> id .\n:=    varible -> id . [ expr ]\nend. ; end else    procedure_statment -> id .\nend. ; end else    procedure_statment -> id . ( expr_list )",
    "states[36].kernel\nLookahead    Production\nend. ; function procedure end else    compound_statment -> begin . optional_statment end",
    "states[36].epsilon\nLookahead    Production\nend    optional_statment -> .",
    "states[37].kernel\nLookahead    Production\nbegin ;    subprogram_declaration -> subprogram_declarations subprogram_declaration ; .",
    "states[38].kernel\nLookahead    Production\nfunction procedure ;    subprogram_declarations -> supprogram_head declarations compound_statment .",
    "states[39].kernel\nLookahead    Production\nvar begin    supprogram_head -> function id arguments . : standard_type ;",
    "states[40].kernel\nLookahead    Production\n: ;    arguments -> ( . parameter_list )",
    "states[41].kernel\nLookahead    Production\nvar begin    supprogram_head -> procedure id arguments . ;",
    "states[42].kernel\nLookahead    Production\nfunction procedure begin var    declarations -> declarations var id_list : type . ;",
    "states[43].kernel\nLookahead    Production\n; )    type -> standard_type .",
    "states[44].kernel\nLookahead    Production\n; )    type -> array . [ int .. int ] of standard_type",
    "states[45].kernel\nLookahead    Production\n; )    standard_type -> integer .",
    "states[46].kernel\nLookahead    Production\n; )    standard_type -> real .",
    "states[47].kernel\nLookahead    Production\n; )    standard_type -> string .",
    "states[48].kernel\nLookahead    Production\n; )    standard_type -> boolean .",
    "states[49].kernel\nLookahead    Production\n$    P -> program id output ; declarations subprogram_declaration begin optional_statment end. .",
    "states[50].kernel\nLookahead    Production\nend. ; end    statment_list -> statment_list ; . optional_statment",
    "states[50].epsilon\nLookahead    Production\nend. ; end    optional_statment -> .",
    "states[51].kernel\nLookahead    Production\nend. ; end else    statment -> varible := . expr",
    "states[52].kernel\nLookahead    Production\nend. ; end else    statment -> if expr . then statment else statment\nend. ; end else    statment -> if expr . then statment",
    "states[53].kernel\nLookahead    Production\nthen do end. ; end ) , ] else to downto    expr -> simple_expr .\nthen do end. ; end ) , ] else to downto    expr -> simple_expr . relop simple_expr\nthen < <= <> = >= > + - or do end. ; end ) , ] else to downto    simple_expr -> simple_expr . addop term",
    "states[54].kernel\nLookahead    Production\nthen < <= <> = >= > + - or do end. ; end ) , ] else to downto    simple_expr -> term .\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    term -> term . mulop factor",
    "states[55].kernel\nLookahead    Production\nthen < <= <> = >= > + - or do end. ; end ) , ] else to downto    simple_expr -> sign . term",
    "states[56].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    term -> factor .",
    "states[57].kernel\nLookahead    Production\nid int float string boolean ( not    sign -> + .",
    "states[58].kernel\nLookahead    Production\nid int float string boolean ( not    sign -> - .",
    "states[59].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> id .\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> id . ( expr_list )",
    "states[60].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> int .",
    "states[61].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> float .",
    "states[62].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> string .",
    "states[63].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> boolean .",
    "states[64].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> ( . expr )",
    "states[65].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> not . factor",
    "states[66].kernel\nLookahead    Production\nend. ; end else    statment -> while expr . do statment",
    "states[67].kernel\nLookahead    Production\nend. ; end else    statment -> for varible . := expr st_for st_for2 do statment",
    "states[68].kernel\nLookahead    Production\n:=    varible -> id .\n:=    varible -> id . [ expr ]",
    "states[69].kernel\nLookahead    Production\nend. ; end else    procedure_statment -> id ( . expr_list )",
    "states[69].epsilon\nLookahead    Production\n) ,    expr_list -> .",
    "states[70].kernel\nLookahead    Production\n:=    varible -> id [ . expr ]",
    "states[71].kernel\nLookahead    Production\nend. ; function procedure end else    compound_statment -> begin optional_statment . end",
    "states[72].kernel\nLookahead    Production\nvar begin    supprogram_head -> function id arguments : . standard_type ;",
    "states[73].kernel\nLookahead    Production\n: ;    arguments -> ( parameter_list . )\n) ;    parameter_list -> parameter_list . ; id_list : type",
    "states[74].kernel\nLookahead    Production\n) ;    parameter_list -> id_list . : type\n: ,    id_list -> id_list . , id",
    "states[75].kernel\nLookahead    Production\nvar begin    supprogram_head -> procedure id arguments ; .",
    "states[76].kernel\nLookahead    Production\nfunction procedure begin var    declarations -> declarations var id_list : type ; .",
    "states[77].kernel\nLookahead    Production\n; )    type -> array [ . int .. int ] of standard_type",
    "states[78].kernel\nLookahead    Production\nend. ; end    statment_list -> statment_list ; optional_statment .",
    "states[79].kernel\nLookahead    Production\nend. ; end else    statment -> varible := expr .",
    "states[80].kernel\nLookahead    Production\nend. ; end else    statment -> if expr then . statment\nend. ; end else    statment -> if expr then . statment else statment",
    "states[81].kernel\nLookahead    Production\nthen < <= <> = >= > + - or do end. ; end ) , ] else to downto    simple_expr -> simple_expr addop . term",
    "states[82].kernel\nLookahead    Production\nthen do end. ; end ) , ] else to downto    expr -> simple_expr relop . simple_expr",
    "states[83].kernel\nLookahead    Production\n+ - id int float string boolean ( not    relop -> < .",
    "states[84].kernel\nLookahead    Production\n+ - id int float string boolean ( not    relop -> <= .",
    "states[85].kernel\nLookahead    Production\n+ - id int float string boolean ( not    relop -> <> .",
    "states[86].kernel\nLookahead    Production\n+ - id int float string boolean ( not    relop -> = .",
    "states[87].kernel\nLookahead    Production\n+ - id int float string boolean ( not    relop -> >= .",
    "states[88].kernel\nLookahead    Production\n+ - id int float string boolean ( not    relop -> > .",
    "states[89].kernel\nLookahead    Production\nid int float string boolean ( not    addop -> + .",
    "states[90].kernel\nLookahead    Production\nid int float string boolean ( not    addop -> - .",
    "states[91].kernel\nLookahead    Production\nid int float string boolean ( not    addop -> or .",
    "states[92].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    term -> term mulop . factor",
    "states[93].kernel\nLookahead    Production\nid int float string boolean ( not    mulop -> * .",
    "states[94].kernel\nLookahead    Production\nid int float string boolean ( not    mulop -> / .",
    "states[95].kernel\nLookahead    Production\nid int float string boolean ( not    mulop -> div .",
    "states[96].kernel\nLookahead    Production\nid int float string boolean ( not    mulop -> mod .",
    "states[97].kernel\nLookahead    Production\nid int float string boolean ( not    mulop -> and .",
    "states[98].kernel\nLookahead    Production\nthen < <= <> = >= > + - or do end. ; end ) , ] else to downto    simple_expr -> sign term .\nthen < <= <> = >= > + - or do end. ; end * / div mod and ) , ] else to downto    term -> term . mulop factor",
    "states[99].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> id ( . expr_list )",
    "states[99].epsilon\nLookahead    Production\n) ,    expr_list -> .",
    "states[100].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> ( expr . )",
    "states[101].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> not factor .",
    "states[102].kernel\nLookahead    Production\nend. ; end else    statment -> while expr do . statment",
    "states[103].kernel\nLookahead    Production\nend. ; end else    statment -> for varible := . expr st_for st_for2 do statment",
    "states[104].kernel\nLookahead    Production\nend. ; end else    procedure_statment -> id ( expr_list . )\n) ,    expr_list -> expr_list . , expr",
    "states[105].kernel\nLookahead    Production\n) ,    expr_list -> expr .",
    "states[106].kernel\nLookahead    Production\n:=    varible -> id [ expr . ]",
    "states[107].kernel\nLookahead    Production\nend. ; function procedure end else    compound_statment -> begin optional_statment end .",
    "states[108].kernel\nLookahead    Production\nvar begin    supprogram_head -> function id arguments : standard_type . ;",
    "states[109].kernel\nLookahead    Production\n) ;    parameter_list -> parameter_list ; . id_list : type",
    "states[110].kernel\nLookahead    Production\n: ;    arguments -> ( parameter_list ) .",
    "states[111].kernel\nLookahead    Production\n) ;    parameter_list -> id_list : . type",
    "states[112].kernel\nLookahead    Production\n; )    type -> array [ int . .. int ] of standard_type",
    "states[113].kernel\nLookahead    Production\nend. ; end else    statment -> if expr then statment . else statment\nend. ; end else    statment -> if expr then statment .",
    "states[114].kernel\nLookahead    Production\nthen < <= <> = >= > + - or do end. ; end ) , ] else to downto    simple_expr -> simple_expr addop term .\nthen < <= <> = >= > + - or do end. ; end ) , ] else * / div mod and to downto    term -> term . mulop factor",
    "states[115].kernel\nLookahead    Production\nthen do end. ; end ) , ] else to downto    expr -> simple_expr relop simple_expr .\nthen do end. ; end ) , ] else + - or to downto    simple_expr -> simple_expr . addop term",
    "states[116].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    term -> term mulop factor .",
    "states[117].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> id ( expr_list . )\n) ,    expr_list -> expr_list . , expr",
    "states[118].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> ( expr ) .",
    "states[119].kernel\nLookahead    Production\nend. ; end else    statment -> while expr do statment .",
    "states[120].kernel\nLookahead    Production\nend. ; end else    statment -> for varible := expr . st_for st_for2 do statment",
    "states[121].kernel\nLookahead    Production\n) ,    expr_list -> expr_list , . expr",
    "states[122].kernel\nLookahead    Production\nend. ; end else    procedure_statment -> id ( expr_list ) .",
    "states[123].kernel\nLookahead    Production\n:=    varible -> id [ expr ] .",
    "states[124].kernel\nLookahead    Production\nvar begin    supprogram_head -> function id arguments : standard_type ; .",
    "states[125].kernel\nLookahead    Production\n) ;    parameter_list -> parameter_list ; id_list . : type\n: ,    id_list -> id_list . , id",
    "states[126].kernel\nLookahead    Production\n) ;    parameter_list -> id_list : type .",
    "states[127].kernel\nLookahead    Production\n; )    type -> array [ int .. . int ] of standard_type",
    "states[128].kernel\nLookahead    Production\nend. ; end else    statment -> if expr then statment else . statment",
    "states[129].kernel\nLookahead    Production\nthen < <= <> = >= > * / div mod and + - or do end. ; end ) , ] else to downto    factor -> id ( expr_list ) .",
    "states[130].kernel\nLookahead    Production\nend. ; end else    statment -> for varible := expr st_for . st_for2 do statment",
    "states[131].kernel\nLookahead    Production\nid int    st_for -> to .",
    "states[132].kernel\nLookahead    Production\nid int    st_for -> downto .",
    "states[133].kernel\nLookahead    Production\n) ,    expr_list -> expr_list , expr .",
    "states[134].kernel\nLookahead    Production\n) ;    parameter_list -> parameter_list ; id_list : . type",
    "states[135].kernel\nLookahead    Production\n; )    type -> array [ int .. int . ] of standard_type",
    "states[136].kernel\nLookahead    Production\nend. ; end else    statment -> if expr then statment else statment .",
    "states[137].kernel\nLookahead    Production\nend. ; end else    statment -> for varible := expr st_for st_for2 . do statment",
    "states[138].kernel\nLookahead    Production\ndo    st_for2 -> id .",
    "states[139].kernel\nLookahead    Production\ndo    st_for2 -> int .",
    "states[140].kernel\nLookahead    Production\n) ;    parameter_list -> parameter_list ; id_list : type .",
    "states[141].kernel\nLookahead    Production\n; )    type -> array [ int .. int ] . of standard_type",
    "states[142].kernel\nLookahead    Production\nend. ; end else    statment -> for varible := expr st_for st_for2 do . statment",
    "states[143].kernel\nLookahead    Production\n; )    type -> array [ int .. int ] of . standard_type",
    "states[144].kernel\nLookahead    Production\nend. ; end else    statment -> for varible := expr st_for st_for2 do statment .",
    "states[145].kernel\nLookahead    Production\n; )    type -> array [ int .. int ] of standard_type ."
]